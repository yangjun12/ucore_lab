###lab3-report


#练习一

代码的分析如下：
```
 ptep=get_pte(mm->pgdir,addr,perm);
 if(ptep==NULL){
	 goto failed;
 }
```
首先按照给定的pgdir以及addr去获得一个地址指针，如果这个地址指针为空，那么就说明是失败。
如果这个地址位零，那么就需要我们分配给它一页，如果分配的这一页为空那么就说明分配页失败。
页目录表项和页表可以记录一个页的访问或者分配以及权限的信息，对于各种页置换算反我们需要记录相应的信息，如fifo算法记录这个页进入页表的时间，LRU记录访问或修改时间，如果是时钟算法就需要标志位。


出现了访问异常，硬件陷入了内核态，需要维护堆栈，记录程序现场，如果发现发生了异常嵌套，根据操作系统的种类不同，不同种类的系统有不同的处理方式，如ucore就认为出现了两次异常而系统崩溃，有的系统可以继续将异常优先级区分进行堆栈入栈出栈的操作，硬件对于寄存器要注意处理，其他交给操作系统处理即可。正常的页替换算法只是需要由操作系统进行，而一旦出现了异常还是需要硬件处理，对于内存的赋值操作也需要硬件进行。


#练习二

代码思路，首先是对于vmm.c文件的对应函数进行修改
```
     if(swap_init_ok) {
         struct Page *page=NULL;
        ret=swap_in(mm,addr,&page);
        if(ret!=0){
        	goto failed;
        }
        page_insert(mm->pgdir,page,addr,perm);
        swap_map_swappable(mm,addr,page,1);
     }else{
    	 goto failed;
     }
```
首先看是否可以进行swap操作，如果不能就failed，如果可以进行swap就需要删除旧的页（已经在swap当中完成），把新的页面进行insert操作，随后修改页表，让这个页面可以被替换以进行后续操作。

接着需要对于swap_fifo.c文件进行操作，这些操作比较简单，加入和删除按照fifo原则替换头部的page即可，此处就不再赘述了。

我认为目前的swap_manager结构可能并不能满足实现扩展时钟算法的要求，首先对于标志位的处理并不明确，另外时钟周期如何计算也是一个问题，因为并没有什么时钟的变量在整个ucore当中显示。

我的想法是对于整个struct再维护一个链表，这个链表尽可能节约空间，它同步于整个页的swap维护的链表，只是记录对应的swap页的标志位信息，当然也可以使用数组进行记录，不过在swap当中要有变量记录数组下标，要么节约空间，要么节省时间，看需要什么了。而时钟周期没有太想好，是否是使用实际当中的时间对其分成若干份，对于每一份为一个单位时间，当需要swap的时候，在一个单位时间当中访问一个页面，去看他的标志位，是否可以进行替换，一般的时候这个模拟的“时钟”就转起来进行访问。

在扩展之后的clock算法当中，被替换的页的特点是对应的两个标志位，修改位和使用位都是0的页可以被替换出去。

根据上面的维护的链表（或者是数组），扫过去发现对应的标志位是满足被换出页的要求的就是识别了具有这样的特征。

当出现了需要访问一个页，它确确实实真的存在于磁盘当中但它并不在内存里面，而此时内存当中的页已经满了，需要进行页替换，按照时钟的访问先delete掉需要换掉的页，然后把对应需要加上去的页加上去完成换入操作。

